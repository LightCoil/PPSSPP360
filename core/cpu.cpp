#include "cpu.h"

/**
 * Конструктор CPU.
 * Создаём JIT-рантайм и передаём ему указатели на state и memory.
 */
CPU::CPU(PPCMemory& mem, CPUState& state)
    : memory_(mem),
      state_(state),
      jit_(&state_, &memory_)  // Предполагаем, что JitRuntime принимает (CPUState*, PPCMemory*)
{
    // Дополнительно можно сразу инициализировать JIT‑таблицы, собрать заголовок кода и т.д.
}

/**
 * Деструктор.
 * Все ресурсы, связанные с выдачей кода JIT, освобождаются в самом jit_. 
 */
CPU::~CPU() {
    // JitRuntime обычно сам освобождает всю сгенерированную память. 
    // Если понадобятся дополнительные действия — добавьте их здесь.
}

/**
 * Сбрасываем состояние CPU и JIT в «чистое» состояние.
 */
void CPU::Reset() {
    // 1) Сбрасываем регистры и PC
    state_.ResetAllRegisters();
    state_.SetPC(0x08800000);  // обычно PSP запускает код с 0x08800000

    // 2) Сбрасываем состояние JIT‑движка:
    jit_.Reset();
}

/**
 * Step() выполняет ровно одну инструкцию PSP через JIT‑движок.
 * JitRuntime::ExecuteNext() берет текущий PC из state_, транслирует инструкцию(и) и
 * меняет state_ (включая новый PC).
 */
void CPU::Step() {
    // Проверим, что JIT правильно проинициализирован
    // (например, llvm только при первом вызове сгенерировал код, но это внутри jit_).
    jit_.ExecuteNext();
}
